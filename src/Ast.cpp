#include "Ast.h"
#include "SymbolTable.h"
#include "Unit.h"
#include "Instruction.h"
#include "IRBuilder.h"
#include <string>
#include <stack>
#include "Type.h"

extern Unit unit;
extern MachineUnit mUnit;
extern FILE *yyout;
int Node::counter = 0;
IRBuilder *Node::builder = nullptr;

Node::Node()
{
    seq = counter++;
}

void Node::backPatch(std::vector<Instruction *> &list, BasicBlock *bb)
{
    for (auto &inst : list)
    {
        if (inst->isCond())
            dynamic_cast<CondBrInstruction *>(inst)->setTrueBranch(bb);
        else if (inst->isUncond())
            dynamic_cast<UncondBrInstruction *>(inst)->setBranch(bb);
    }
}

std::vector<Instruction *> Node::merge(std::vector<Instruction *> &list1, std::vector<Instruction *> &list2)
{
    std::vector<Instruction *> res(list1);
    res.insert(res.end(), list2.begin(), list2.end());
    return res;
}

void Ast::genCode(Unit *unit)
{
    // fprintf(stderr, ";Ast::genCode!\n");
    IRBuilder *builder = new IRBuilder(unit);
    Node::setIRBuilder(builder);
    root->genCode();
}

void FunctionDef::genCode()
{
    // fprintf(stderr, ";FunctionDef::genCode!\n");
    Unit *unit = builder->getUnit();
    Function *func = new Function(unit, se);
    BasicBlock *entry = func->getEntry();
    // set the insert point to the entry basicblock of this function.
    builder->setInsertBB(entry);

    if (decl)
        decl->genCode();
    stmt->genCode();

    /**
     * Construct control flow graph. You need do set successors and predecessors for each basic block.
     * Todo
     */
    for (auto block = func->begin(); block != func->end(); block++)
    {

        Instruction *inst = (*block)->rbegin();
        Instruction *i = (*block)->begin();
        while (i != inst)
        {
            if (i->isCond() || i->isUncond())
                (*block)->remove(i);
            i = i->getNext();
        }
        if (inst->isCond())
        {
            BasicBlock *truebb, *falsebb;
            truebb = dynamic_cast<CondBrInstruction *>(inst)->getTrueBranch();
            falsebb = dynamic_cast<CondBrInstruction *>(inst)->getFalseBranch();
            (*block)->addSucc(truebb);
            (*block)->addSucc(falsebb);
            truebb->addPred(*block);
            falsebb->addPred(*block);
        }
        else if (inst->isUncond()) // 无条件跳转指令可获取跳转的目标块
        {
            BasicBlock *dst = dynamic_cast<UncondBrInstruction *>(inst)->getBranch();
            (*block)->addSucc(dst);
            dst->addPred(*block);
            // B7:                               	; preds = %B5, %B6
            // B6: 会报错，所以要加上返回语句
            if (dst->empty())
            {
                if (((FunctionType *)(se->getType()))->getRetType() ==
                    TypeSystem::intType)
                    new RetInstruction(new Operand(new ConstantSymbolEntry(
                                           TypeSystem::intType, 0)),
                                       dst);
                else if (((FunctionType *)(se->getType()))->getRetType() ==
                         TypeSystem::voidType)
                    new RetInstruction(nullptr, dst);
            }
        }
        // 不是跳转语句，但也不是ret，可能是void没有写return
        else if (!inst->isRet())
        {
            if (((FunctionType *)(se->getType()))->getRetType() ==
                TypeSystem::voidType)
            {
                new RetInstruction(nullptr, *block);
            }
        }
    }
}

void BinaryExpr::genCode()
{
    // fprintf(stderr, ";BinaryExpr::genCode!\n");
    BasicBlock *bb = builder->getInsertBB();
    Function *func = bb->getParent();
    if (op == AND)
    {
        BasicBlock *trueBB = new BasicBlock(
            func); // if the result of lhs is true, jump to the trueBB.
        if (isCond())
        {
            // fprintf(stderr, "and expr is cond\n");
            expr1->setCond();
            expr2->setCond();
        }
        expr1->genCode();
        backPatch(expr1->trueList(), trueBB);
        // fprintf(stderr, "If true, jmp to B%d\n", trueBB->getNo());
        builder->setInsertBB(
            trueBB); // set the insert point to the trueBB so that intructions
                     // generated by expr2 will be inserted into it.
        expr2->genCode();
        true_list = expr2->trueList();
        false_list = merge(expr1->falseList(), expr2->falseList());
    }
    else if (op == OR)
    {
        // Todo
        BasicBlock *trueBB = new BasicBlock(func);
        if (this->isCond())
        {
            // fprintf(stderr, "and expr is cond\n");
            expr1->setCond();
            expr2->setCond();
        }
        expr1->genCode();
        backPatch(expr1->falseList(), trueBB);
        builder->setInsertBB(trueBB);
        expr2->genCode();
        true_list = merge(expr1->trueList(), expr2->trueList());
        false_list = expr2->falseList();
    }
    else if (op >= GT && op <= NEQUAL)
    {
        // Todo

        if (this->isCond())
        { // 如果形如 （a && b） ！=0 ，就要把iscond传递下去， 形如a ！=0
            // 则不用，目的是让与或逻辑表达式的unary自己生成cmp
            if (!expr1->isUnary() && !expr1->isPrimary() && !expr1->isFuncCall())
                expr1->setCond();
            if (!expr2->isUnary() && !expr2->isPrimary() && !expr2->isFuncCall())
                expr2->setCond();
        }
        expr1->genCode();
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        if (src1->getType()->getSize() == 1)
        {
            Operand *dst = new Operand(new TemporarySymbolEntry(
                TypeSystem::intType, SymbolTable::getLabel()));
            new ZextInstruction(dst, src1, bb);
            src1 = dst;
        }
        if (src2->getType()->getSize() == 1)
        {
            Operand *dst = new Operand(new TemporarySymbolEntry(
                TypeSystem::intType, SymbolTable::getLabel()));
            new ZextInstruction(dst, src2, bb);
            src2 = dst;
        }
        int cmpop;
        switch (op)
        {
        case GT:
            cmpop = CmpInstruction::G;
            break;
        case GTE:
            cmpop = CmpInstruction::GE;
            break;
        case LT:
            cmpop = CmpInstruction::L;
            break;
        case LTE:
            cmpop = CmpInstruction::LE;
            break;
        case EQUAL:
            cmpop = CmpInstruction::E;
            break;
        case NEQUAL:
            cmpop = CmpInstruction::NE;
            break;
        }
        new CmpInstruction(cmpop, dst, src1, src2, bb);

        BasicBlock *truebb, *falsebb, *tempbb;

        truebb = new BasicBlock(func);
        falsebb = new BasicBlock(func);
        tempbb = new BasicBlock(func);

        true_list.push_back(new CondBrInstruction(truebb, tempbb, dst, bb));
        false_list.push_back(new UncondBrInstruction(falsebb, tempbb));
    }
    else if (op >= ADD && op <= MOD)
    {
        expr1->genCode();
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch (op)
        {
        case ADD:
            opcode = BinaryInstruction::ADD;
            break;
        case SUB:
            opcode = BinaryInstruction::SUB;
            break;
        case MUL:
            opcode = BinaryInstruction::MUL;
            break;
        case DIV:
            opcode = BinaryInstruction::DIV;
            break;
        case MOD:
            opcode = BinaryInstruction::MOD;
            break;
        }
        new BinaryInstruction(opcode, dst, src1, src2, bb);
        if (this->isCond())
        {
            Function *func = bb->getParent();
            BasicBlock *trueBB = new BasicBlock(func);
            BasicBlock *tempbb = new BasicBlock(func);
            BasicBlock *falseBB = new BasicBlock(func);
            SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
            Constant *digit = new Constant(se); // 0
            Operand *op = this->getOperand();
            Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
            new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), bb);
            this->trueList().push_back(
                new CondBrInstruction(trueBB, tempbb, t, bb));
            this->falseList().push_back(new UncondBrInstruction(falseBB, tempbb));
        }
    }
}

void FuncCallExpr::genCode()
{
    // fprintf(stderr, ";FuncCallExpr::genCode!\n");
    std::vector<Operand *> operands;
    ExprNode *temp = params;
    while (temp)
    {
        temp->genCode();
        operands.push_back(temp->getOperand());
        temp = ((ExprNode *)temp->getNext());
    }
    BasicBlock *bb = builder->getInsertBB();
    if (!dst)
    {
        // fprintf(stderr, ";dst is null!\n");
    }
    else
    {
        // fprintf(stderr, ";dst is not null!\n");
    }
    new CallInstruction(dst, symbolEntry, operands, bb);
    if (this->isCond())
    {
        Function *func = bb->getParent();
        BasicBlock *trueBB = new BasicBlock(func);
        BasicBlock *tempbb = new BasicBlock(func);
        BasicBlock *falseBB = new BasicBlock(func);
        SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
        Constant *digit = new Constant(se); // 0
        Operand *op = this->getOperand();
        Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
        new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), bb);
        this->trueList().push_back(
            new CondBrInstruction(trueBB, tempbb, t, bb));
        this->falseList().push_back(new UncondBrInstruction(falseBB, tempbb));
    }
}

void UnaryExpr::genCode()
{
    // fprintf(stderr, ";UnaryExpr::genCode!\n");
    //  todo
    expr->genCode();
    BasicBlock *bb;
    // 如果是常量，就做替换了  -4  -a
    if (op == NEG && (!this->isConst()))
    {
        Operand *src1 = new Operand(new ConstantSymbolEntry(TypeSystem::intType, 0));
        Operand *src2;
        // dst = new Operand(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()));
        bb = builder->getInsertBB();
        if (expr->isBool())
        {
            src2 = new Operand(new TemporarySymbolEntry(
                TypeSystem::intType, SymbolTable::getLabel()));
            new ZextInstruction(src2, expr->getOperand(), bb);
        }
        else
            src2 = expr->getOperand();
        new BinaryInstruction(BinaryInstruction::SUB, dst, src1, src2, bb);

        if (this->isCond())
        {
            Function *func = bb->getParent();
            BasicBlock *trueBB = new BasicBlock(func);
            BasicBlock *tempbb = new BasicBlock(func);
            BasicBlock *falseBB = new BasicBlock(func);
            SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
            Constant *digit = new Constant(se); // 0
            Operand *op = this->getOperand();
            Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
            new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), bb);
            this->trueList().push_back(new CondBrInstruction(trueBB, tempbb, t, bb));
            this->falseList().push_back(new UncondBrInstruction(falseBB, tempbb));
        }
    }
    if (op == POS && (!this->isConst()))
    {
        Operand *src1 = new Operand(new ConstantSymbolEntry(TypeSystem::intType, 0));
        Operand *src2;
        // dst = new Operand(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()));
        bb = builder->getInsertBB();
        if (expr->isBool())
        {
            src2 = new Operand(new TemporarySymbolEntry(
                TypeSystem::intType, SymbolTable::getLabel()));
            new ZextInstruction(src2, expr->getOperand(), bb);
        }
        else
            src2 = expr->getOperand();
        new BinaryInstruction(BinaryInstruction::ADD, dst, src1, src2, bb);
        if (this->isCond())
        {
            Function *func = bb->getParent();
            BasicBlock *trueBB = new BasicBlock(func);
            BasicBlock *tempbb = new BasicBlock(func);
            BasicBlock *falseBB = new BasicBlock(func);
            SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
            Constant *digit = new Constant(se); // 0
            Operand *op = this->getOperand();
            Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
            new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), bb);
            this->trueList().push_back(
                new CondBrInstruction(trueBB, tempbb, t, bb));
            this->falseList().push_back(new UncondBrInstruction(falseBB, tempbb));
        }
    }
    if (op == NOT)
    {
        BasicBlock *bb = builder->getInsertBB();
        Operand *src = expr->getOperand();
        // 不是布尔型，需要cmp转为bool，然后作xor取非
        if (!expr->isBool())
        {
            expr->setBool();
            Operand *cmp0;
            int size = expr->getSymPtr()->getType()->getSize();
            fprintf(stderr, ";size::::%d!\n", size); // 32
            cmp0 = new Operand(new ConstantSymbolEntry(TypeSystem::intType, 0));

            // 中间bool结果
            SymbolEntry *se_bool = new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel());
            Operand *tmp = new Operand(se_bool);
            new CmpInstruction(CmpInstruction::NE, tmp, src, cmp0, bb);
            src = tmp;
        }
        new NotInstruction(dst, src, bb);
    }
}

void Constant::genCode()
{
    // we don't need to generate code.
    // No, we need
    // fprintf(stderr, ";Constant::genCode!\n");
    // eg. while(1)
    if (this->isCond())
    {
        BasicBlock *bb = builder->getInsertBB();
        Function *func = bb->getParent();
        BasicBlock *trueBB = new BasicBlock(func);
        BasicBlock *tempbb = new BasicBlock(func);
        BasicBlock *falseBB = new BasicBlock(func);
        SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
        Constant *digit = new Constant(se); // 0
        Operand *op = this->getOperand();
        Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
        new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), bb);
        this->trueList().push_back(
            new CondBrInstruction(trueBB, tempbb, t, bb));
        this->falseList().push_back(new UncondBrInstruction(falseBB, tempbb));
    }
}

void Id::genCode()
{
    // fprintf(stderr, ";Id::genCode!\n");
    BasicBlock *bb = builder->getInsertBB();
    Operand *addr =
        dynamic_cast<IdentifierSymbolEntry *>(symbolEntry)->getAddr();
    if (type->isInt())
    {
        // fprintf(stderr, ";Id::genCode is int!\n");
        new LoadInstruction(dst, addr, bb);
    }
    else if (type->isArray())
    {
        // a[2][3]
        // fprintf(stderr, ";Id::genCode is array!\n");
        if (indicesExpr)
        {
            Type *type = ((ArrayType *)(this->type))->getElementType();
            Type *curtype = this->type;
            Operand *tempSrc = addr;
            Operand *tempDst = dst;
            ExprNode *idx = indicesExpr;
            bool paramIsFirst = false;
            bool isFirst = true;
            while (true)
            {
                // f(int arr[])，此时len=-1
                if (((ArrayType *)curtype)->getLength() == -1)
                {
                    Operand *tmpdst = new Operand(new TemporarySymbolEntry(
                        new PointerType(type), SymbolTable::getLabel()));
                    tempSrc = tmpdst;
                    new LoadInstruction(tmpdst, addr, bb);
                    paramIsFirst = true;
                    isFirst = false;
                }
                // a[2][3]...
                if (!idx)
                {
                    Operand *tmpdst = new Operand(new TemporarySymbolEntry(
                        new PointerType(type), SymbolTable::getLabel()));
                    Operand *idx = new Operand(
                        new ConstantSymbolEntry(TypeSystem::intType, 0));
                    new GepInstruction(tmpdst, tempSrc, idx, bb);
                    tempDst = tmpdst;
                    break;
                }

                idx->genCode();
                auto gep = new GepInstruction(tempDst, tempSrc, idx->getOperand(), bb, paramIsFirst);

                if (!paramIsFirst && isFirst)
                {
                    gep->setFirst();
                    isFirst = false;
                }
                if (paramIsFirst)
                    paramIsFirst = false;
                if (type->isInt())
                    break;

                type = ((ArrayType *)type)->getElementType();
                curtype = ((ArrayType *)curtype)->getElementType();
                tempSrc = tempDst;
                tempDst = new Operand(new TemporarySymbolEntry(
                    new PointerType(type), SymbolTable::getLabel()));
                idx = (ExprNode *)(idx->getNext());
            }
            dst = tempDst;
            // rval，右值还需要load出值
            if (!left)
            {
                Operand *tmpdst = new Operand(new TemporarySymbolEntry(
                    TypeSystem::intType, SymbolTable::getLabel()));
                new LoadInstruction(tmpdst, dst, bb);
                dst = tmpdst;
            }
        }
        else
        {
            // 没有indices的array     eg. int a[10], type of a: int*
            // -1是没存，是形参
            if (((ArrayType *)(this->type))->getLength() == -1)
            {
                Operand *tmpdst = new Operand(new TemporarySymbolEntry(
                    new PointerType(
                        ((ArrayType *)(this->type))->getElementType()),
                    SymbolTable::getLabel()));
                new LoadInstruction(tmpdst, addr, bb);
                dst = tmpdst;
            }
            // 存了，实参
            else
            {
                Operand *idx = new Operand(
                    new ConstantSymbolEntry(TypeSystem::intType, 0));
                auto gep = new GepInstruction(dst, addr, idx, bb);
                // 从头开始，计算地址
                gep->setFirst();
            }
        }
    }
    if (this->isCond())
    {
        bb = builder->getInsertBB();
        Function *func = bb->getParent();
        BasicBlock *trueBB = new BasicBlock(func);
        BasicBlock *tempbb = new BasicBlock(func);
        BasicBlock *falseBB = new BasicBlock(func);
        SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
        Constant *digit = new Constant(se); // 0
        Operand *op = this->getOperand();
        Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
        new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), bb);
        this->trueList().push_back(
            new CondBrInstruction(trueBB, tempbb, t, bb));
        this->falseList().push_back(new UncondBrInstruction(falseBB, tempbb));
    }
    /*BasicBlock *bb = builder->getInsertBB();
    if (!symbolEntry)
    {
        fprintf(stderr, ";se is nullptr!\n");
    }
    else
    {
        fprintf(stderr, ";se is NOT nullptr! %s\n", symbolEntry->toStr().c_str());
    }
    Operand *addr = dynamic_cast<IdentifierSymbolEntry *>(symbolEntry)->getAddr();
    new LoadInstruction(dst, addr, bb);
    if (isCond)
    {
        Function *func = bb->getParent();
        BasicBlock *trueBB = new BasicBlock(func);
        BasicBlock *tempbb = new BasicBlock(func);
        BasicBlock *falseBB = new BasicBlock(func);
        SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
        Constant *digit = new Constant(se); // 0
        Operand *op = this->getOperand();
        Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
        new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), bb);
        this->trueList().push_back(
            new CondBrInstruction(trueBB, tempbb, t, bb));
        this->falseList().push_back(new UncondBrInstruction(falseBB, tempbb));
    }*/
}

void InitValExpr::genCode()
{
}

void IfStmt::genCode()
{
    // fprintf(stderr, ";IfStmt::genCode\n");
    Function *func;
    BasicBlock *then_bb, *end_bb, *cond_bb, *bb;

    bb = builder->getInsertBB();
    func = builder->getInsertBB()->getParent();
    cond_bb = new BasicBlock(func);
    then_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);

    new UncondBrInstruction(cond_bb, bb);

    builder->setInsertBB(cond_bb); // 进入cond
    cond->genCode();

    // Operand *op = cond->getOperand();
    //  非布尔的表达式
    //  if (op->getType()->getSize() == 32 || op->getType()->isFunc())
    //  {
    //      BasicBlock *bb = cond->builder->getInsertBB();
    //      SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
    //      Constant *digit = new Constant(se); // 0
    //      Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
    //      new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), bb);
    //      op = t;
    //      new CondBrInstruction(then_bb, end_bb, op, bb);
    //  }

    backPatch(cond->trueList(), then_bb);
    backPatch(cond->falseList(), end_bb);

    builder->setInsertBB(then_bb); // then
    thenStmt->genCode();
    then_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(end_bb);
}

void IfElseStmt::genCode()
{
    // fprintf(stderr, ";IfElseStmt::genCode!\n");
    //  Todo
    Function *func;
    BasicBlock *then_bb, *else_bb, *end_bb, *cond_bb, *bb;

    func = builder->getInsertBB()->getParent();
    bb = builder->getInsertBB();
    then_bb = new BasicBlock(func);
    else_bb = new BasicBlock(func);
    cond_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);

    cond_bb->addPred(bb);
    bb->addSucc(cond_bb); // bb->cond_bb

    then_bb->addPred(cond_bb);
    cond_bb->addSucc(then_bb); // cond => then/else
    else_bb->addPred(cond_bb);
    cond_bb->addSucc(else_bb);

    end_bb->addPred(then_bb);
    then_bb->addSucc(end_bb); // then/else => end
    end_bb->addPred(else_bb);
    else_bb->addSucc(end_bb);

    new UncondBrInstruction(cond_bb, bb);

    builder->setInsertBB(cond_bb);
    cond->genCode();
    // Operand *op = cond->getOperand();
    // if (cond->getOperand()->getType()->getSize() == 32)
    // {
    //     // fprintf(stderr, "$$$$$$$$$$$$$$$$$$$$$$\n");
    //     SymbolEntry *se = new ConstantSymbolEntry(TypeSystem::intType, 0);
    //     Constant *digit = new Constant(se); // 0
    //     Operand *t = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
    //     new CmpInstruction(CmpInstruction::NE, t, op, digit->getOperand(), cond_bb);
    //     op = t;
    //     new CondBrInstruction(then_bb, else_bb, op, cond_bb);
    // }
    backPatch(cond->trueList(), then_bb);
    backPatch(cond->falseList(), else_bb);

    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    then_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(else_bb);
    elseStmt->genCode();
    else_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, else_bb);

    builder->setInsertBB(end_bb);
}

void WhileStmt::genCode()
{
    // fprintf(stderr, ";WhileStmt::genCode!\n");
    Function *func;
    BasicBlock *cond_bb, *while_bb, *end_bb, *bb;
    bb = builder->getInsertBB();
    func = builder->getInsertBB()->getParent();
    this->cond_bb = cond_bb = new BasicBlock(func);
    this->end_bb = end_bb = new BasicBlock(func);
    while_bb = new BasicBlock(func);

    new UncondBrInstruction(cond_bb, bb);

    builder->setInsertBB(cond_bb);
    cond->genCode();
    backPatch(cond->trueList(), while_bb);
    backPatch(cond->falseList(), end_bb);

    builder->setInsertBB(while_bb);
    stmt->genCode();

    while_bb = builder->getInsertBB();
    new UncondBrInstruction(cond_bb, while_bb);

    builder->setInsertBB(end_bb);
}

void ContinueStmt::genCode()
{
    // Todo
    // uncond branch to whilestmt's cond bb
    Function *f = builder->getInsertBB()->getParent();
    BasicBlock *bb = builder->getInsertBB();
    new UncondBrInstruction(((WhileStmt *)whileStmt)->get_cond_bb(), bb);
    BasicBlock *cond_bb = new BasicBlock(f);
    builder->setInsertBB(cond_bb);
}

void BreakStmt::genCode()
{
    // Todo
    // uncond branch to whilestmt's end bb
    Function *f = builder->getInsertBB()->getParent();
    BasicBlock *bb = builder->getInsertBB();
    new UncondBrInstruction(((WhileStmt *)whileStmt)->get_end_bb(), bb);
    BasicBlock *end_bb = new BasicBlock(f);
    builder->setInsertBB(end_bb);
}

void BlankStmt::genCode()
{
}

void EmptyStmt::genCode()
{
}

void ExprStmt::genCode()
{
    // fprintf(stderr, ";ExprStmt::genCode!\n");
    expr->genCode();
}

void CompoundStmt::genCode()
{
    // fprintf(stderr, ";CompoundStmt::genCode!\n");
    //  Todo
    stmt->genCode();
}

void SeqNode::genCode()
{
    // fprintf(stderr, ";SeqStmt::genCode!\n");
    //  Todo
    stmt1->genCode();
    stmt2->genCode();
}

void DeclStmt::genCode()
{
    // fprintf(stderr, ";DeclStmt::genCode!\n");
    //  fprintf(stderr, "%s\n", expr->getSymPtr()->toStr().c_str());
    extern Unit unit;
    DeclStmt *node = this;
    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(node->getID()->getSymPtr());
    BasicBlock *bb;

    if (se->isGlobal())
    {
        Operand *addr;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        se->setAddr(addr);
        unit.insertGlob(se);
        mUnit.insertGlob(se);
    }
    else if (se->isLocal() || se->isParam())
    {
        // fprintf(stderr, ";DeclStmt::genCode is LOCAL or PARAM!\n");
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        alloca = new AllocaInstruction(addr, se);
        // allocate space for local id in function stack.
        entry->insertFront(alloca); // allocate instructions should be inserted
                                    // into the begin of the entry block.
        Operand *temp = nullptr;
        if (se->isParam())
        {
            temp = se->getAddr();
        }
        se->setAddr(addr); // set the addr operand in symbol entry so that
                           // we can use it in subsequent code generation.
        if (expr)
        {
            // if.是数组的初值列表
            // else.是普通的表达式
            if (expr->isInitValExpr())
            {
                Operand *init = nullptr;

                bb = builder->getInsertBB();
                ExprNode *curNode = expr;
                std::stack<ExprNode *> stk;
                std::vector<int> expridx;
                // current index in current dimension，idx伴随curNode
                expridx.push_back(0);
                // curNode现在是{x,x,x,x}的头结点
                while (curNode)
                {
                    // 向下 {{{2,3}},3,{4,5,{6},7}}
                    if (curNode->isInitValExpr())
                    {
                        stk.push(curNode);
                        expridx.push_back(0);
                        curNode = ((InitValExpr *)curNode)->getExpr();
                        continue;
                    }
                    // 向右

                    // curNode不是list，而是单独的expr
                    curNode->genCode();
                    Type *type =
                        ((ArrayType *)(se->getType()))->getElementType();
                    Operand *tempSrc = addr;
                    Operand *tempDst;
                    Operand *index;
                    bool isFirst = true;
                    int idx = 1;
                    // [4 x [2 x [1 x i32]]]   [2 x [1 x i32]]
                    while (true)
                    {
                        tempDst = new Operand(new TemporarySymbolEntry(
                            new PointerType(type),
                            SymbolTable::getLabel()));
                        index = (new Constant(new ConstantSymbolEntry(
                                     TypeSystem::intType, expridx[idx++])))
                                    ->getOperand();
                        auto gep =
                            new GepInstruction(tempDst, tempSrc, index, bb);
                        gep->setInit(init);

                        if (isFirst)
                        {
                            gep->setFirst();
                            isFirst = false;
                        }
                        if (type->isIntLike())
                        {
                            // is int rather than [2 x 4i]....
                            gep->setFinal();
                            init = tempDst;
                            break;
                        }
                        type = ((ArrayType *)type)->getElementType();
                        tempSrc = tempDst;
                    }
                    new StoreInstruction(tempDst, curNode->getOperand(), bb);

                    // 更新curNode，向右
                    while (true)
                    {
                        if (curNode->getNext())
                        {
                            curNode = (ExprNode *)(curNode->getNext());
                            expridx[expridx.size() - 1]++;
                            break;
                        }
                        else
                        {
                            curNode = stk.top();
                            stk.pop();
                            expridx.pop_back();
                            if (stk.empty())
                                goto DECLSTMT_WHILE_END;
                        }
                    }
                }
            }
            else
            {
                // 非初值列表的exp
                bb = builder->getInsertBB();
                expr->genCode();
                Operand *src = expr->getOperand();
                new StoreInstruction(addr, src, bb);
            }
        }

    DECLSTMT_WHILE_END:
        if (se->isParam())
        {
            // fprintf(stderr, ";DeclStmt::genCode is Param!\n");
            bb = builder->getInsertBB();
            new StoreInstruction(addr, temp, bb);
        }
    }
    // int a,b=2,c;
    if (this->getNext())
    {
        this->getNext()->genCode();
    }
}

void ReturnStmt::genCode()
{
    // fprintf(stderr, ";ReturnStmt::genCode!\n");
    //  Todo
    //  当前基本块
    BasicBlock *bb = builder->getInsertBB();
    Operand *src = nullptr;
    // Return Exp， Exp即retValue，为Exp生成代码
    if (retValue)
    {
        retValue->genCode();
        // 生成指令，output一下
        src = retValue->getOperand();
    }
    new RetInstruction(src, bb);
}

void AssignStmt::genCode()
{
    // fprintf(stderr, ";AssignStmt::genCode!\n");
    BasicBlock *bb = builder->getInsertBB();
    expr->genCode();
    Operand *addr = nullptr;
    if (lval->getSymPtr()->getType()->isInt())
        addr = dynamic_cast<IdentifierSymbolEntry *>(lval->getSymPtr())
                   ->getAddr();
    else if (lval->getSymPtr()->getType()->isArray())
    {
        ((Id *)lval)->setLeft();
        lval->genCode();
        addr = lval->getOperand();
        // Type* type = new PointerType(TypeSystem::intType);
        // SymbolEntry* addr_se = new TemporarySymbolEntry(type,
        // SymbolTable::getLabel()); addr = new Operand(addr_se);
    }
    Operand *src = expr->getOperand();
    /***
     * We haven't implemented array yet, the lval can only be ID. So we just
     * store the result of the `expr` to the addr of the id. If you want to
     * implement array, you have to caculate the address first and then store
     * the result into it.
     */
    new StoreInstruction(addr, src, bb);
}

void Ast::typeCheck(Type *retType)
{
    if (root != nullptr)
        root->typeCheck();
}

void FunctionDef::typeCheck(Type *retType)
{
    SymbolEntry *se = this->getSymPtr();
    Type *ret = ((FunctionType *)(se->getType()))->getRetType();
    StmtNode *stmt = this->stmt;
    if (!stmt)
    {
        if (ret != TypeSystem::voidType)
        {
            fprintf(stderr, "non-void function does not return a value\n");
            exit(EXIT_FAILURE);
        }
    }
    stmt->typeCheck(ret);
}

void BinaryExpr::typeCheck(Type *retType)
{
    // Todo
}

void FuncCallExpr::typeCheck(Type *retType)
{
}

void UnaryExpr::typeCheck(Type *retType)
{
    // TOdo
}

void Constant::typeCheck(Type *retType)
{
    // Todo
}

void Id::typeCheck(Type *retType)
{
    // Todo
}

void InitValExpr::typeCheck(Type *retType)
{
}

void IfStmt::typeCheck(Type *retType)
{
    // Todo
    if (thenStmt)
        thenStmt->typeCheck(retType);
}

void IfElseStmt::typeCheck(Type *retType)
{
    // Todo
    if (thenStmt)
        thenStmt->typeCheck(retType);
    if (elseStmt)
        elseStmt->typeCheck(retType);
}

void WhileStmt::typeCheck(Type *retType)
{
    if (stmt)
        stmt->typeCheck(retType);
}

void BreakStmt::typeCheck(Type *retType)
{
}

void ContinueStmt::typeCheck(Type *retType)
{
}

void BlankStmt::typeCheck(Type *retType)
{
}

void EmptyStmt::typeCheck(Type *retType)
{
}

void ExprStmt::typeCheck(Type *retType)
{
}

void CompoundStmt::typeCheck(Type *retType)
{
    // Todo
    if (stmt)
        return stmt->typeCheck(retType);
}

void SeqNode::typeCheck(Type *retType)
{
    // Todo
    if (stmt1)
        stmt1->typeCheck(retType);
    if (stmt2)
        stmt2->typeCheck(retType);
}

void DeclStmt::typeCheck(Type *retType)
{
}

void ReturnStmt::typeCheck(Type *retType)
{
    if (!retType)
    {
        fprintf(stderr, "expected unqualified-id\n");
        exit(EXIT_FAILURE);
    }
    if (retValue && retType->isVoid())
    {
        fprintf(stderr, "return-statement with a value, in function returning \'void\'\n");
        exit(EXIT_FAILURE);
    }
    if (!retType->isVoid())
    {
        if (!retValue)
        {
            fprintf(stderr, "return-statement with no value, in function returning \'%s\'\n", retType->toStr().c_str());
            exit(EXIT_FAILURE);
        }
        Type *type = retValue->getSymPtr()->getType(true);
        if ((type->isIntLike() && retType->isFloatLike()) || (type->isFloatLike() && retType->isIntLike()))
        {
            fprintf(stderr, "In funcdef : function return type not match.\n");
            exit(EXIT_FAILURE);
        }
    }
}

void AssignStmt::typeCheck(Type *retType)
{
    // Todo
}

void BinaryExpr::output(int level)
{
    // fprintf(stderr, "output binaryexpr.\n");
    std::string op_str;
    switch (op)
    {
    case ADD:
        op_str = "add";
        break;
    case SUB:
        op_str = "sub";
        break;
    case MUL:
        op_str = "mul";
        break;
    case DIV:
        op_str = "div";
        break;
    case MOD:
        op_str = "mod";
        break;
    case AND:
        op_str = "and";
        break;
    case OR:
        op_str = "or";
        break;
    case LT:
        op_str = "less_than";
        break;
    case LTE:
        op_str = "less_or_equal_than";
        break;
    case GT:
        op_str = "greater_than";
        break;
    case GTE:
        op_str = "greater_or_equal_than";
        break;
    case EQUAL:
        op_str = "equal_to";
        break;
    case NEQUAL:
        op_str = "not_equal_to";
        break;
    }
    fprintf(yyout, "%*cBinaryExpr\top: %s\n", level, ' ', op_str.c_str());
    expr1->output(level + 4);
    expr2->output(level + 4);
}

void FuncCallExpr::output(int level)
{
}

void UnaryExpr::output(int level)
{
    std::string op_str;
    switch (op)
    {
    case POS:
        op_str = "pos";
        break;
    case NEG:
        op_str = "neg";
        break;
    case NOT:
        op_str = "not";
        break;
    }
    fprintf(yyout, "%*cUnaryExpr\top: %s\n", level, ' ', op_str.c_str());
    expr->output(level + 4);
}

void Ast::output()
{
    fprintf(yyout, "program\n");
    if (root != nullptr)
        root->output(4);
}

void Constant::output(int level)
{
    std::string type, value;
    type = symbolEntry->getType()->toStr();
    value = symbolEntry->toStr();
    if (symbolEntry->getType() == TypeSystem::constIntType)
        fprintf(yyout, "%*cIntegerLiteral\tvalue: %s\ttype: %s\n", level, ' ', value.c_str(), type.c_str());
    else if (symbolEntry->getType() == TypeSystem::constFloatType)
        fprintf(yyout, "%*cFloatLiteral\tvalue: %s\ttype: %s\n", level, ' ', value.c_str(), type.c_str());
}

void Id::output(int level)
{
    std::string name, type;
    int scope;
    name = symbolEntry->toStr();
    type = symbolEntry->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry *>(symbolEntry)->getScope();
    fprintf(yyout, "%*cId\tname: %s\tscope: %d\ttype: %s\n", level, ' ',
            name.c_str(), scope, type.c_str());
}

void InitValExpr::output(int level)
{
    std::string type;
    if (symbolEntry->getType())
        type = symbolEntry->getType()->toStr();
    fprintf(yyout, "%*cInitValueListExpr\ttype: %s\n", level, ' ',
            type.c_str());
    Node *temp = expr;
    while (temp)
    {
        temp->output(level + 4);
        temp = temp->getNext();
    }
}

void InitValExpr::addExpr(ExprNode *expr)
{
    if (this->expr == nullptr)
    {
        assert(exprNum == 0);
        exprNum++;
        this->expr = expr;
    }
    else
    {
        exprNum++;
        ExprNode *temp = this->expr;
        while (temp->getNext())
            temp = temp->getNext();
        // this->expr->setNext(expr);
        temp->setNext(expr);
    }
}

bool InitValExpr::isFull()
{
    ArrayType *type = (ArrayType *)(this->symbolEntry->getType());
    return exprNum == type->getLength();
}

void InitValExpr::addZero()
{
    Type *type = ((ArrayType *)(this->getType()))->getElementType();
    if (type->isArray())
    {
        while (!isFull())
            this->addExpr(new InitValExpr(new ConstantSymbolEntry(type, 0)));
        ExprNode *temp = expr;
        while (temp)
        {
            ((InitValExpr *)temp)->addZero();
            temp = (ExprNode *)(temp->getNext());
        }
    }
    if (type->isInt())
    {
        while (!isFull())
        {
            this->addExpr(new Constant(new ConstantSymbolEntry(type, 0)));
        }
        return;
    }
}

void ExprStmt::output(int level)
{
    fprintf(yyout, "%*cExprStmt\n", level, ' ');
    expr->output(level + 4);
}

void CompoundStmt::output(int level)
{
    fprintf(yyout, "%*cCompoundStmt\n", level, ' ');
    stmt->output(level + 4);
}

void SeqNode::output(int level)
{
    stmt1->output(level);
    stmt2->output(level);
}

void DeclStmt::output(int level)
{
    fprintf(yyout, "%*cDeclStmt\n", level, ' ');
    id->output(level + 4);
    if (expr)
        expr->output(level + 4); // 打印初值
    if (this->getNext())
    {
        // fprintf(yyout,"have next to print:\n");
        this->getNext()->output(level);
    }
}

void IfStmt::output(int level)
{
    fprintf(yyout, "%*cIfStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
    // fprintf(stderr, "ifthenstmt\n");
}

void IfElseStmt::output(int level)
{
    fprintf(yyout, "%*cIfElseStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
    elseStmt->output(level + 4);
}

void WhileStmt::output(int level)
{
    fprintf(yyout, "%*cWhileStmt\n", level, ' ');
    cond->output(level + 4);
    stmt->output(level + 4);
}

void BreakStmt::output(int level)
{
    fprintf(yyout, "%*cBreakStmt\n", level, ' ');
}

void ContinueStmt::output(int level)
{
    fprintf(yyout, "%*cContinueStmt\n", level, ' ');
}

void BlankStmt::output(int level)
{
    fprintf(yyout, "%*cBlankStmt\n", level, ' ');
}

void EmptyStmt::output(int level)
{
    fprintf(yyout, "%*cEmptyStmt\n", level, ' ');
}

void ReturnStmt::output(int level)
{
    fprintf(yyout, "%*cReturnStmt\n", level, ' ');
    if (retValue)
        retValue->output(level + 4);
}

void AssignStmt::output(int level)
{
    fprintf(yyout, "%*cAssignStmt\n", level, ' ');
    // fprintf(stderr, "output assignstmt.\n");
    lval->output(level + 4);
    expr->output(level + 4);
}

void FunctionDef::output(int level)
{
    std::string name, type;
    name = se->toStr();
    type = se->getType()->toStr();
    fprintf(yyout, "%*cFunctionDefine function name: %s, type: %s\n", level, ' ',
            name.c_str(), type.c_str());
    std::vector<Type *> params = (dynamic_cast<FunctionType *>(this->se->getType()))->getParams();
    for (size_t i = 0; i < params.size(); i++)
    {
        fprintf(yyout, "%*cFunction params: %s\n", level, ' ',
                params[i]->toStr().c_str());
    }
    stmt->output(level + 4);
}
